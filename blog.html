<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog</title>
    <link
      href="https://cdn.jsdelivr.net/npm/daisyui@3.6.4/dist/full.css"
      rel="stylesheet"
      type="text/css"
    />
  </head>
  <body>
    <div class="px-24 py-10 bg-white text-black">
      <h1 class="text-lg font-bold">
        1.Discuss the scope of var, let and const.
      </h1>
      <p>
        <span class="text-lg font-bold">Answer:</span>
      </p>
      <p>
        ==>><span class="text-lg font-bold">"var"</span> Function Scope:
        Variables declared with var are function-scoped. This means they are
        accessible throughout the entire function in which they are defined.
        Hoisting: Variables declared with var are hoisted to the top of their
        containing function or global scope. This means you can use a var
        variable before it's declared, but it will be undefined until its
        declaration is reached. <p><span class="text-lg font-bold">Example:</span> function example() { if (true) { var x =
            10; } console.log(x); // 10 (accessible outside the if block) }</p> ==>>
            <span class="text-lg font-bold">"let</span> Block Scope: Variables declared with let are block-scoped. They
        are only accessible within the block (enclosed by curly braces) in which
        they are defined. Block scope typically includes statements like loops,
        conditional statements, and functions. Hoisting: Like var, let variables
        are hoisted, but they are in a "temporal dead zone" until their
        declaration is reached. This means you can't use them before
        declaration. <p><span class="text-lg font-bold">Example:</span>function example() { if (true) { let y = 20; }
            console.log(y); // ReferenceError: y is not defined } </p>==>> <span class="text-lg font-bold">"const"</span> Block
        Scope: Variables declared with const are also block-scoped, just like
        let. Constant Value: const variables are constant, which means their
        value cannot be reassigned once it's set. However, for objects and
        arrays declared with const, the content (properties or elements) can
        still be modified. Hoisting: Similar to let, const variables are hoisted
        and are in the "temporal dead zone" until their declaration is reached.
        <p><span class="text-lg font-bold">Example:</span>function example() { if (true) { const z = 30; } console.log(z);
            // ReferenceError: z is not defined }</p>
      </p>
      <br>
      <h1 class="text-lg font-bold">2.Tell us the use cases of null and undefined.</h1>
      <p>
        <span class="text-lg font-bold">Answer:</span><p>
            ==>><span class="text-lg font-bold">"null"</span> Intentional Absence of Value: null is a value that
        represents the intentional absence of any object value or no value at
        all. Use Cases: Often used when you want to explicitly indicate that a
        variable or object property should have no value or is empty. It can be
        used as a placeholder value to initialize variables that will be
        assigned a value later. Sometimes returned from functions or APIs to
        indicate that no valid result or object is available.
        </p>
        <p>
         ==>><span class="text-lg font-bold">"undefined"</span>
        Default Value for Uninitialized Variables: undefined is the default
        value assigned to variables that have been declared but haven't been
        assigned a value. Use Cases: Variables declared but not initialized are
        automatically set to undefined. Function parameters that are not
        provided with an argument are undefined. Properties of objects that have
        not been defined are also undefined. It can be used to check if a
        variable has been assigned a value.
        </p>
      </p>
      <br>
      <h1 class="text-lg font-bold">3.What do you mean by REST API?.</h1>
      <p>
        <span class="font-bold text-lg">Answer:</span><p>==>>REST API stands for Representational State Transfer Application
            Programming Interface. It is a widely used architectural style for
            designing networked applications and services. REST is not a specific
            technology or protocol but rather a set of architectural constraints and
            principles for creating web services. Here are the key characteristics
            and concepts associated with REST APIs: 
            <p>1. **Statelessness**: REST APIs
                are stateless, meaning that each request from a client to the server
                must contain all the information needed to understand and process the
                request. The server doesn't store any client state between requests.
                This makes REST APIs scalable and easy to cache. </p>
            <p>2. **Client-Server
                Architecture**: REST separates the client (user interface) from the
                server (data storage and processing), allowing them to evolve
                independently. This separation enhances scalability and simplifies
                development. </p>
            <p>3. **HTTP Methods**: REST APIs use standard HTTP methods to
                perform operations on resources. The four primary HTTP methods used in
                REST are: - **GET**: Retrieve data from the server. - **POST**: Create a
                new resource on the server. - **PUT**: Update an existing resource on
                the server. - **DELETE**: Remove a resource from the server. </p>
            <p>4. **Resources**: Resources are the key abstractions in REST. Each resource
                is identified by a unique URL (Uniform Resource Locator). Resources can
                represent objects, data, or services, and they can have multiple
                representations (e.g., JSON, XML, HTML). </p>
            <p>5. **Uniform Interface**: REST
                APIs follow a uniform and consistent interface, which simplifies
                interactions between clients and servers. This uniformity is achieved
                through the use of standard HTTP methods and status codes. </p>
           <p> 6. **Stateless Communication**: Communication between client and server in
            REST is stateless, meaning that each request/response pair is
            independent. The server doesn't store information about the client's
            state between requests. </p>
           <p> 7. **Representation**: Resources can have
            multiple representations, such as JSON, XML, or HTML. Clients can
            request the representation they prefer using the `Accept` header in the
            HTTP request. </p>
            <p>8. **Idempotence**: Some HTTP methods (e.g., GET and PUT)
                are idempotent, meaning that performing the same operation multiple
                times has the same result as performing it once. For example, sending
                multiple identical PUT requests to update a resource will have the same
                effect as sending just one PUT request. </p>
           <p> 9. **HATEOAS (Hypermedia as the Engine of Application State)**: This principle suggests that the API
            should provide links or references to related resources in the
            responses, allowing clients to discover and navigate the API
            dynamically. RESTful APIs are commonly used for building web services
            that can be consumed by various client applications, including web and
            mobile apps. They provide a scalable, flexible, and widely adopted way
            to expose and consume data and services over the internet.</p></p>
      </p>
    </div>
  </body>
  <script src="https://cdn.tailwindcss.com"></script>
</html>
